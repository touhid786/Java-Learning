
Hey guys.

Welcome to Concept and Coding.

And let's start in the second part of the collection video.

And we have already covered what is Iteratable what is collection.

And today I am going to start one very important concept with this queue and also comparator and comparable

very very frequently asked interview question.

Okay.

So let's start with our queues.

So as the name itself is very clear, you already know that in the queue is something like standing

one after the other.

Right.

So let's say you have a queue right.

This is your front.

This is your front and this is your rear.

So any new item which is added it is added at the back.

Right.

It's always added at the rear.

And anything which is getting removed it is removed from the front right.

Similarly, like we are standing in a queue of a anything like movie theater, right?

So anyone who wants a the ticket first?

Stand in a queue at the end and anyone who gets the ticket is from the front.

And then they go.

Okay, so this is a very basic concept of queue.

But this whatever the functionality like first come first serve right.

First in first out Fifo approach.

This is not generally you can say that there are different flavors of queues like priority queue is

one of them.

Right.

So at the base level you can say that queue is something like this.

But there are different flavors which are available which also have certain different, uh, behaviors

of a queue.

So we will also see that.

So queue is what queue is an interface child of a collection interface class.

Generally queue follows Fifo approach.

But there are exceptions like priority queue queue support all the methods available in collection plus

some other methods mentioned below.

So Q is the child of collection interface, right?

So it also has all the methods which are available in collection plus some other methods also.

So what are the new methods which Q has this has this six methods add, offer, poll, remove, peek

and element.

So let's say we have an Q.

So what does add will do.

So we will see an example also bottom uh but let's first understand what does different methods means

and how they are different to each other.

So add.

So what Add will do it.

Insert the element into the queue.

It returns true if insertion is successful and exception if insertion fails.

Right.

And what it does it returns a null null element insertion is not allowed.

It will throw null pointer exception.

So whenever you call and let's say add a five so it will insert an element five, right.

And if you try to say that add null it will throw null pointer exception because a null element is not

allowed.

And if there is any issue while doing an addition exception will be thrown.

There is a second method called offer.

It is exactly same as add, but only difference is that if insertion fails then it return false instead

of throwing an exception, but it is also used to insert an element into the queue.

Only difference is when insertion fails, it returns false instead of exception.

That's all.

Then we have poll and remove again the same difference, only the difference in the exception part.

But the poll retrieves and removes the head of the queue.

Returns null if q is empty.

So you have a Q, right?

So what happens is so let's say this is the head or you can say that front.

Okay.

So what it will do is it retrieves and removes the head of the Q.

When you do pull, what it will do is it will remove the head of the Q and returns this whatever the

element was there.

Right.

And it returns null.

If the Q is empty, then there is something called remove.

So it is exactly same as pole.

But if the q is empty, it returns an exception which is no such element exception.

And while the pole returns null.

Similarly, we have peek and element.

So what does peek say is that.

So you have an element in the Q.

It just retrieves the value present at the head but does not remove it.

So whenever you do peek so whatever element is present at the head or front it.

Just return it, right.

But it doesn't remove like what pole does pole also return it like, but it doesn't.

But it also removes it while peak doesn't removed it.

And if the queue is empty, it returns null.

And what does element do?

Element is also same as the peak.

What it will do is it will return the head of the queue but doesn't remove it.

But if queue is empty, it will return an exception.

So these are the six methods and we will see an example.

So this is the interface.

So queue is an interface which has exposed this six methods right now whichever the class like priority

queue is one of the class.

So they will implement this based upon the requirement how they are adding an element.

Right.

So Iteratable Iteratable is a interface than collection is a sub interface of the iterable.

Then queue is also again a sub interface of the collection and priority queue is something which implements

the queue.

So now let's jump into the priority queue.

And I would say that if you are doing data structure questions and you have been doing a heap, then

in Java, the heap implementation you have to use priority queue.

If you are solving any data structure question using heap, then you have to use priority queue.

Why?

I will tell you.

So C priority queue is of two type minimum priority queue and max priority queue.

And this priority queue uses what data structure.

Internally it uses priority heap.

So when I say that minimum priority queue you can say that it is very very equivalent to min heap.

When I say maximum priority queue you can say that it is very equivalent to max heap, right?

Internally the data it stores in a heap format.

So elements are ordered according to their natural ordering by default or by comparator provided during

the queue construction time.

Okay.

So let's see this line with an example.

So let's say I have this minimum priority queue.

So this is just a normal method mean.

So now I am creating a priority queue.

Priority queue of integer equals to I am creating a new priority queue like this.

In the constructor I haven't provided anything right.

I just created a new priority queue.

So what if I haven't provided anything?

What?

This priority queue.

This queue would be stored data in a what format is the ascending format or descending or sorting format?

What format?

Right.

So priority queue says that it's store the order the data according to the natural ordering.

Right.

Ordered according to the natural ordering by default.

So even though you are just creating a priority queue, right.

You haven't.

You just say that.

Okay, I wanted a queue and I want to insert a data inside a queue, but internally it do certain kind

of ordering priority queue, right?

And if you don't provide anything what is the by default uh ordering.

It follows natural ordering.

So natural ordering is like for integer natural ordering is ascending order.

And if you are using a string if here you are using a string, it's I think Lexicographically are sorted.

So that's the natural order.

And if you want to change that natural order you have to use comparator.

How to use comparator.

I'll tell you.

But first use this.

So currently I created a priority queue with an empty constructor.

Means by default it is used.

It is ordering by the natural ordering.

So it is an integer.

So it might be doing an ascending order right.

And whenever ascending order is minimum at first minimum at first right.

So minimum at first means it has to create a min heap right.

So now this priority queue is kind of constructing would be a min heap okay.

So now let's say I am and you already know that how the min heap is going to constructed internally

right.

So here let's say I have add five.

So it will add five here first, then min priority queue dot add two.

So two is less than five.

So it would be inserted here.

Then it will do heapify.

So two will be here and five would be here.

Because two is lesser than this.

We are constructing a min heap.

And why we are constructing a min heap because we haven't added anything into the constructor.

Constructor is currently empty, so it will use its.

It will order it based on its natural ordering and generally its ascending natural base.

For integer, a natural ordering is ascending minimum at first and for minimum at first.

In heap it is generally nothing but a min heap.

Then we have eight, so eight is greater than two.

It should be at right, so it is still satisfy the heapify property.

Then one one is less than two, one is less than five.

Here.

then it will do.

Heapify.

So this will swap and then it will swap with this.

So one will come here, two will come here, five will come here eight is here.

Okay.

So after inserting this minheap would be like this.

Now let's print all the values.

So for printing the values we know that it follows a level order traversal.

So how it will print.

So it will print first one.

Then it will print two and eight.

Then it will print the last level 51285.

So 1285.

But now let's try to remove the element from the priority queue.

So here for insertion I have used add add method of the queue.

Now for insertion which one I have to use.

Either I can use remove or I can use poll right.

So I am using poll.

So I am iterating over the priority utilities, not empty.

And I am doing a poll.

So what it will happen is so it will remove the top element and it will return it also.

So it will be inside here and I am printing it.

Remove from top value would be one.

Right.

And then after removing it it will heapify again.

So it would be the next minimum would be at the top 258.

So after that it would be two.

Then after that it would be next minimum would be five and then after would be eight.

And after that uh, priority queue would be an empty and it goes out.

Okay.

So even though if you see that priority queue, even though we are just inserting the data, right.

So generally if you see that queue first come first come first out, so generally it should be 5281.

Right.

That's how they inserted after five.

Two comes after two.

Eight comes.

And if we take out, it generally should be the same order.

But in the priority queue it has only of two types minimum or max.

If you don't provide anything in the constructor, it will use kind of a min heap.

Now if you wanted to change it to a max, we have to use a comparator and I'll tell you how.

So this is clear priority queues of two types min and max, which is nothing but a similar to a heap

data structure.

Okay.

So now let's see a max priority queue example.

Everything is same.

Only thing is like okay what priority queue I wanted.

So new priority queue.

If I wanted a min I have to just nothing to provide into the constructor.

But if I want a max, I can provide a constructor, a comparator.

So this is a comparator.

This is very important.

And this is my next topic is comparator versus comparator.

Very, very frequently asked in an interview.

And also it's very good for understanding also.

So don't worry about this how I added this comparator.

Because once I tell you about the comparator and comparable, then I can again come to this line and

tell how it's, uh, constructing in a decreasing order how it's making into a max heap.

Okay, but understand this now, when I wanted a max heap or wanted to store the data into a decreasing

order.

Right.

I have provided a comparator.

Now, this comparator tells that hey stores the data into a reverse order, right?

Now when I am storing it.

So 5 to 8 one.

So earlier it would be five, then I am adding two.

So in a it stores the data in a heap format.

Right.

And I told that it should be max heap.

And so two is less than this.

No heapify because had a parent is greater than the child, then eight and then it will do Heapify 825

then 18215.

I think it's all satisfied.

The heapify format.

I am just printing it so it follows an order level.

So first eight, then two and five and then 182518251.

And then let's do a polling like remove it from the top.

So first it will remove eight right.

So it will remove eight.

Then it will heapify after removing internally.

So next big number would be at top five then two then one.

So it would be five then two, then one, 8521.

Got it.

And when the priority max priority queue is empty it will go out.

So priority queue.

We know now right?

So now you know that when you have to use priority queue whenever you wanted a heap property, then

you have to use a priority queue.

Right.

So priority queue either so it doesn't store.

So whenever you want it like hey I have a data one, two, three, seven in the whatever the same order

it comes the store in the same order.

No don't use them.

Priority queue because priority queue is of two type only minimum and maximum.

It's kind of a min heap.

It's kind of a max heap.

If you don't provide anything into the constructor, it would be a min heap.

And if you provide the comparator right, you can change the min heap to a max heap.

And how?

Now I will tell you.

So these are the certain time complexities of priority queue.

This is exactly same as heap generally nothing difference.

And so you know that add generally takes n log n because of the Heapify property.

Peek is just at the look at the top hat, so it's Big-O of one pole and remove head element.

It's log n because, uh, let's say A25.

Even though you remove it in O of one, then you have to do heapify again.

So that's log n so o of one plus log n it's log n.

But if you have to remove some arbitrary element let's say I have to remove uh uh certain like a four.

So it has to iterate over each element and then remove four.

Then it's a big O of n.

So these are the time complexity of priority queue.

Now while learning this priority queue we have come up with something called comparator which is used

to change the ordering.

Right now let's have this better understanding now because this is very important.

So comparator and comparable both provides a way to sort the collection of objects.

So it provides a way or you can say that helps in sorting, but it doesn't sort.

It just help in sorting.

Okay.

So comparator and comparable both helps in sorting of the collection of objects.

How.

Let's see first an issue like uh why they need it.

Actually first we have to understand the need of them.

So let's say that I am creating a very primitive collection sorting.

Uh, I am doing a primitive objects like so integer, integer int is a primitive data type.

So I have created its collection an array 1234.

And I am doing arrays dot sort and provided this.

So now here if you see that when you go inside this sort method which JDK provides internally what it

does it.

It uses the certain quicksort algorithm.

Okay.

So here if you see that for this uh sorting.

So here it provides a quicksort algorithm.

And it just sort it uh in ascending order.

It will sort it into one, two, three, four in ascending order.

Okay.

Because this is the direct implementation which we are using.

Uh quicksort dot sort okay.

But now let's say okay I can sort in ascending order.

But how to sort in descending order.

That's one question.

Okay.

Another is another problem.

I would say that object collection sorting.

So you know that one requirement which you have is like okay, if I have an integer array, how to sort

in descending order.

That's one requirement.

Another is object collection sorting.

So now let's say I have instead of integer primitive type I have an object Car.

Car has to think what?

What is the car name and the car type?

And this is just a simple constructor.

Now I am creating an array of an object car array.

Right?

Of three of the size I have given.

And in the three what I am putting is car name is let's say SUV type.

It's petrol, second is sedan, type is diesel, third is hatchback and type is CNG.

Just say that I have put that one.

Now I am doing arrays dot sort car array.

Right.

Like I have used for the primitive one arrays dot sort array.

So generally if you see that if you try to do it and doesn't provide whether we have to do it in ascending

or descending order here it sort into the ascending order by its internally, whatever the algorithm

it is using quicksort or whatever, but it sort into the ascending order.

So when I do this, arrays dot sort car array and run the programs it gives me this exception car cannot

be cast to comparable.

Why?

It gives me this.

Why for primitive it is able to sort in ascending order.

Why for this?

Arrays dot sort car array.

Why it is not able to sort it.

Right.

So that is like objects collection.

So this is array is generally also a type of.

A collection.

You can say that.

But what I am trying to say is that object collection.

Sorting is only possible through if you provide a comparator and comparable which helps in sorting.

So now I will tell you the issue here why we got this problem.

So when you have a let's say any number 518 ten in an array or collection anything.

So internally for sorting they compare two values.

Let's say first they are comparing five and eight let's say.

Okay.

So they do compare it.

So which one to keep first.

Which one to keep second.

So do they need swapping.

So currently are they in the correct order or they need swapping okay.

So this has to be decided right.

Whether they need to swap or not.

So generally comparator and comparable expose certain method which actually tells that yes you need

to swap.

It should be eight one, 510 or no, this is the correct ordering for five and eight.

Okay.

So now here it doesn't find that compare method.

So here we have three objects one object two.

We have created three object.

One is with SUV and petrol.

Another is sedan and diesel.

Another is hatchback and CNG.

So we have an array of these three and we are trying to sort it so it internally 012.

So internally it might be comparing this with might be some other object right.

Depending upon the algorithm.

So while comparing it it has to decide whether I need to swap it with or not.

And for that it require it takes help of comparator and comparable.

Right.

So here when it tries to look for the compare hey which one.

Whether I have to swap these two or not.

So it doesn't find a method into the car.

Here the whatever the class car object which we have created right.

It doesn't find any compare method which will tell us while comparing this two whether I have to swap

or not.

Okay, now you can ask me, right?

Hey why car?

How car can have this compare method, right?

How?

How are we gonna do this?

Now let's jump into.

But at least.

Are you aware now you got the issue.

So whenever.

So two things.

First thing is whenever you want to change the natural ordering.

So here arrays dot sort.

It will do a natural ordering of ascending order.

And it might be using certain direct algorithm itself.

Right.

So whenever you want to change hey I don't want to use this, uh, simple quicksort directly because

we know that it will sort in ascending order.

I want to sort in certain different order descending order.

So then you need comparator comparable support.

Second is if you have an object let's say maybe user defined or maybe some other, uh, internally defined

object and you want to sort them.

Then also you need the help of comparator and comparable because we internally object would get compared

to each other, and whether to swap or not, it has to.

No algorithm has to know.

Okay, so now let's see that how to add this support compare method.

Right.

So how to sort the object array with the help of comparator and comparable.

So let's first focus on comparator.

Then we'll come to comparable.

So if you see that comparator comparator is a functional interface.

It's a functional interface which has this abstract method which has this abstract method.

Compare object one.

Object two.

Let's see that.

Okay.

So here uh, let's say that uh comparator go inside this comparator.

So comparator is your functional interface, right.

And here, if you see that this is the abstract method which has which accepts two objects.

Okay.

So what happens is sorting algorithm.

Use this compare method.

Sorting algorithm.

Use this compare method of the comparator to compare two variables and decide whether to swap the variables

or not.

So this compare method.

Generally it should be like.

So it has two values right.

Object one.

Object two.

So earlier I have given the name V1V2.

After that I have changed to object one.

Object two.

So consider this v one as object one and consider this v two as object two.

Okay.

So now this compare method is like object one.

Object two.

If object one greater than object two it should return one.

If object one is equals to equals to object two.

It should return zero if object one is less than object two.

It should return minus one right.

So generally here if you see that.

Our algorithms internally I will show you see whatever the JDK has written the algorithm right.

It is based on this only.

So this compare has two method.

If object one is greater than object two, it is expecting that I will get one greater than zero number.

If both are equal, I will get zero.

If object one is less than object two, I will get certain negative number less than less than zero

number.

Right.

So now let's see that part.

So here I am taking this example okay.

Now let me have this example written also, and we'll see that I'm creating an integer array.

Some random I'm putting into an ordered form 17 351 ten something I've taken just a random.

Okay, now here what I'm trying to do is I want you to sort it.

So I am doing arrays dot sort.

I want to pass this RR array, but I but you know that if I go internally right.

This is an object.

This is not a primitive one.

This is a wrapper object.

Right.

So internally what it calls it calls an object.

Right.

So but I want to sort it into a let's say descending order.

But let's say use this with the comparator.

Right.

So here let's say I am using a comparator one integer a or let's say val one integer val two.

Val one minus val two.

Okay.

So here it's a val one val two.

Okay.

Now what I have done here like and also here, if you see that if I write it like this arrays dot sort.

This is also equivalent to this.

Both are equal actually here.

Now now let's explain this.

See this one.

Now first let me go inside this arrays dot sort.

So which method it will call this array.

And the comparator.

So here if you see that this comparator is a functional interface it has one abstract method which accepts

two variables, two parameters.

So that's why I have sanded that.

This is an array.

And this is the.

I used a lambda expression and passed this expression itself.

Pass this function to that functional interface.

So internally whenever the compare method will get invoked this will get executed.

Okay.

Now let's see this part.

Okay I pass the comparator if c equals to equals to null.

No.

Now let's say it is going inside the merge sort.

Uh.

So if c equals to equals to none no it goes inside.

Let's say merge sort.

So now here if you see that it is doing certain swapping.

So mustard has a logic to swap right now while swapping what it has the logic C dot compare and it passed

the two values right?

If it is also greater than zero.

So now we know that I have passed this as a comparator function.

So whenever it has called dot compare and it passed this two values comma this two values.

So it will invoke this comparator here compare method and pass the two values.

So the two values would I have passed is val one comma val two.

And now it is checking if it is greater than zero.

Then only do the swap.

Let's understand this with an example.

Let's say I have 6419.

Now let's say this is my, uh my one cursor is here.

My another cursor is here.

And one this is my pointer one.

This is my pointer two.

Now I have passed in the compare method.

So compare method accepts two variable right object one and object two.

So in the object one, let's say I have passed six and object two I have passed nine, right?

Six and nine.

So what implementation I have given is val one minus val two, which is nothing but a object one minus

object two.

So six minus nine.

Internally it is doing minus right I am doing minus six minus nine.

It would be negative right?

Right.

It will not be a greater than zero.

So our code which is present into the JDK itself, it checks that if it is greater than zero then only

do the swap.

So here six minus nine is greater than zero.

No it is not greater than zero.

So it will not swap.

So it would be like six nine only.

So smaller would be front of bigger only.

But what if it was like this 941 and let's say six and over one pointer is here, another pointer is

here.

And while passing this I pass here in the object one I passed, let's say uh object one.

Object two.

So let's say I have in the object one I have passed, uh, Val one which is nine.

Val two is nothing but a one.

Now here, when this compare method get invoked, it will do val one minus one two nine minus one.

Which is greater than zero.

Right.

According to algorithm nine minus one.

So this method will get invoked.

It will do object one minus object two as we have provided the implementation here.

So it would be greater than zero.

And it will do swap.

So it would become swap.

So it will become one and nine here.

So it will try to insert here in the ascending order if you see that.

Okay.

So that's what I am trying to say, that what thing you should take out from this is that the comparator

is not doing the sorting algorithm.

Sorting algorithm is already present already there into that.

Whenever you are doing arrays dot sort right internally it might be using quicksort, merge sort time

sort whatever sorting.

But internally it is using this compare method to decide whether I have to swap or not.

Right.

So currently algorithms are written in this format.

If it is greater, if value one object one is greater than object two, swap it right.

If both are equals, do nothing.

And if also object one is less than object two also do nothing, so means it is trying to do in an ascending

format.

Okay.

So this is it.

This is the comparator.

And I think if you have followed the functional interface lambda expression, this is very, very easy.

Looks very easy and clear to you.

And if you are facing difficulty here and what I have done here, please go and check that video first.

Then it makes more sense that what I am, how we are sending this like this.

Right?

But I want to tell you that this comparator helps in just doing the like, whether which one variable

has to swap or not.

It but sorting algorithm is already there.

So now one thing you should know that okay, I get it here.

We have provided a comparator and we have exhibit the same behavior so that it is sorting in ascending

order.

What about this arrays dot sort array.

Here we are not passing this comparator.

Here We have not passed this comparator.

But how is sorting in the ascending order?

So now let us go inside this and check it out.

So it goes.

Now let's say it goes into this object.

Let's say it's going into the merge sort.

It's going into the merge sort part.

So here if you see that it is using compare two method and then use the swap compare two.

This flavor is internally using compare two.

So compare two is available in comparable.

Compare two is available in comparable.

This is also the same thing.

This also compare two also provide this.

That's the behavior that if greater than if object one is greater than object two it should be one else

zero else minus one will come to this compare to.

But what I am trying to say is that it is also using compare two and here integer.

If you see that it implements a comparable.

So it should have one.

Compare two method compare two method which is generally doing that.

So it has compare.

So here it is returning either minus one 0 or 1 right.

If x less than y it is returning minus one.

So nothing but an object one is less than object two return minus one.

If both are equal, return zero.

If x is greater than this, return one.

Okay, so.

But we will come to this comparable.

But what I am trying to say is that internally, no matter which we are using.

So this one is using first one is using x explicitly.

We have provided the comparator.

So it goes into one of the sorting flavor which uses the comparator compare method.

And there is another sort flavor.

If you have just provided this it internally goes to a method of sorting, which uses compareto to decide

whether to swap or not.

And uh, yeah, it against, uh, this behavior only it is sending.

Okay.

So we'll see and check the comparable also.

But at least you are clear right.

Comparator part.

So now here if you see that in this algorithm when I sort it I what I what is the comparator I pass.

Uh so in the comparator I pass two objects.

So val one val two of this integer because any two value can be compared.

Right.

So this should be same as what your collection type is.

So whenever they compare val one minus two only I am doing so six -11.

It should be negative.

So don't swap it.

So it is in ascending order.

But now let's say if I want to sort in a descending order descending order, what I have to do Can we

do just simply like.

Well two minus.

Well one this formula, this implementation.

If I change it we actually start doing the descending order.

For example, earlier it was let's say six and 11.

I am doing well one minus Val two.

Now it's six and uh 11 again I am doing well.

Two minus Val one.

Right.

And our algorithm is which is written is like if greater than zero swap.

That's our algorithm is written right.

So now and here it's called the compare method.

So now let's say compare method.

This is the compare method.

First I am doing val one minus val two.

So this is val one.

This is val two six -11.

It would be negative.

It would return negative negative greater than zero false.

It doesn't swap.

So it isn't sorting in ascending order 611.

But if I start doing well two minus well one.

So this is.

Well one.

This is well two.

Well two minus well one.

Well two minus well one.

So well two is your 11.

Well one is six.

So in the compare method it calls internally this implementation.

And it will do 11 minus six.

It is greater than zero.

Yes 11 minus six is greater than zero.

Yes.

Then swap.

So ultimately it's swapped and it becomes 11 and six.

So now kind of a descending order.

So you can say that just by tweaking here and algorithm remains the same.

Right.

We can do either ascending or either descending.

So that's why internally all the sorting algorithms using this compare method.

And we can it provides the capability to engineer that okay.

Using this we can tweak whether we want to sort in ascending or descending.

So that's why I did.

I have created an integer array 64192 11 some random numbers and sorting.

I have passed the array, but I explicitly passed the comparator also.

And in this comparator, if you see that I have just changed val to minus one, I added.

Now it will always try to sort in the ascending or descending order, right?

Because algorithm is same greater than zero only swap.

Now just I have changed it.

So now let's say this is Val one.

This is well two.

So I have changed it to well two minus well one.

So it's two minus nine.

It's negative.

Negative greater than zero.

Don't swap it.

So nine is still front two is at back.

So it will sort in the descending order.

Okay.

You got this one right.

comparator, how this comparator is.

And similarly if you go that in the priority queue, I have used the same thing.

I have provided the comparator in the priority queue.

The constructor also takes a comparator.

I have just given a comparator.

I okay, its two values always sort in decreasing order.

So for max heap just provide a decreasing order b minus a.

Okay, now let's see an example of the card type I have created a car.

Car has two either car name and car type.

So this one I have.

So I have created this car object which has this three SUV petrol and diesel hatchback CNG.

Now you know that when we try to sort it simple car array, it throws an Issue because it couldn't find

a comparable method.

How to compare this?

Which one to bring first or swap it or not?

So for this how I am solving it using comparator, it is also able to solve through comparable.

But first we are learning comparator.

So here I am solving it through comparator.

So arrays dot sort card array.

Now I am passing a comparator here.

So I have passed two objects.

So whatever the array type is because it gonna be a comparison between these two objects only.

Right.

So car only car is your object one another is object two.

Now I want to compare based on its type let's say on type.

So now I am doing object two dot car type.

So understand that what I am trying to do is object two.

So means I am trying to insert in descending order or something.

Object two dot cartype compares to object one dot car type.

So this is nothing but, uh, compare in a lexicographical order, right?

For a string, right?

So.

So I am doing the same thing which I was doing through integer only, but using compare to for a string

it does a lexicographical kind of ordering, right.

And object two I have used first.

And so it means I want to do in a decreasing order, and it sort based on the type.

Now okay.

So now here, if you see that if I want to sort with the comparator I can change it.

Right.

Let's say if I want to sort based on a card name.

So I have this again same take example SUV sedan hatchback.

Right.

And I have this uh arranged or sort car array object one comma object two.

And what what is the implementation I'm doing?

Object one dot Kaname compares to object two dot Kaname right?

So now I am sorting based on the name and object one here at the first, right?

So means I am trying to sort in an increasing order.

Right?

So now let's say you have.

SUV.

Sedan.

Hatchback.

So this is like we have in a, uh, let's say an array.

This is we are trying to compare this, uh, two.

This two.

And these are the name and the type is there, let's say petrol, diesel, CSV.

But we are comparing with this name.

So let's say this is value one.

This is value two.

So what I am doing is value one dot car name compares to value two dot car name.

So that is nothing but SUV compares to.

hatchback.

Okay, so now here, if you see that SUV compares to a hatchback.

So SUV lexicographically this is greater than hatchback right.

So it will return greater than zero right.

And you know that algorithm right.

When it is greater than zero it does swap.

So hatchback is now your first and SUV is back.

So we are trying to sort in an ascending order.

So here based on the car name, if you see that hatchback is first then sedan then SUV.

So now here if you see that we can do sorting based on lot of flavors.

So we have seen one flavor I can do sort on based on the type on the car itself, and another I can

also do based on the name also.

Okay.

So now here if you see that one.

So this one we have seen.

Right.

Okay.

So now I am trying to do in descending order this is one more example, the same thing.

Now you already know that for sorting in a descending order what you have to do.

Object two compares to object one and on the based on car name, right?

So now it would be in the descending order.

So SUV sedan hatchback.

So based on this we are doing an ordering okay.

So because this is the compare method compares method which we have sent compares method.

Okay.

So now here one thing is if you have followed the Lambda video function interface video, I told you

that there are three ways right for doing so.

This is one of the.

So I currently I have used directly use the lambda expression.

If you don't want to use the lambda expression you can also use that.

So here if you see that I have created a car object, now I can have this like one way is that I created

the new comparator class and implements the comparator.

So when you implement the comparator you have to implement its abstract method.

Compare right.

And when you implement this compare you have to provide what you wanted what functionality you wanted.

So here I am doing oh two object two minus object one.

So some something like a descending order I want to sort right based on car name.

So similarly you can have more comparators like cart type comparator right.

You can have more car type descending comparator, ascending comparator.

Right.

You can have that one.

But you have to implement this functional interface and provide the implementation.

Right.

And while using it how you can use it.

Or you can let's say now I am using instead of an array I am using a collection now.

So here I am using a list of cards as a list.

I have added this three items.

Now I am doing collection dot sort.

So see, one thing is like whether I have been explaining you through a array internally, both are

same.

So here let's see that collections dot sort like let's say it is trying to sort a list.

What it is doing is internally nothing but the same.

It first convert to an array and then call arrays dot sort something.

So that's what we are where we are learning first add on based on the arrays itself.

Because even though you are using a collection now here list, even though you are doing collections.sort

internally, it first convert to an array and then calls the same method arrays dot sort.

So that's the same thing.

So.

But here what now I am passing here is that, uh, I have created a new class called comparator class

car name comparator, which is sorting in decreasing order.

Now I can pass this comparator like this, right?

Even though you can create an anonymous class, also you know that there are three ways, right?

You can either implement it function interface.

Either you can do anonymous or you can do lambda expression.

So generally I am more comfortable in doing a lambda expression and also better itself.

You don't have to create a different class altogether, but you can still this is an option, right?

You can create this.

You can have as many as comparator classes which implements this comparator and have the compare and

pass that comparator into this sorting.

And also in the same class.

If you want to have this only one, only one compare method.

Right.

You don't have a requirement that no, I have I don't want to name comparator car type comparator car

name.

Ascending comparator name.

Descending comparator.

No, I want only one type of uh, uh, kind of, uh, compare method, and nobody should change it also.

Right.

They should only use that.

So you can also use this.

You can create a so whatever the class which you have right in the same class you can implement the

comparator.

And now you have to implement the comparator.

You have to implement this abstract method compare and you can do whatever you want.

So here I am doing based on card name and in ascending order okay.

Now here you whenever somebody has to use it they can pass this like new car object.

And inside that it will call.

They will call the compare method the sorting algorithms.

Right.

But now here you don't have much scope that you cannot create a different comparators like okay I can

create ten comparator providing support for sorting based on car name.

Car type.

Ascending.

Descending.

Right.

But that's a choice.

But at least my point is you should be clear.

Like what?

This comparator is, right?

Whether you are doing through Lambda, whether you are doing through creating a separate method itself

and passing it, or whether you are creating an anonymous also, that's also fine.

Okay, but at least you should know comparator and how it is beneficial.

But now let's see to the comparable.

So now here if you see that comparable also is having one method compare to.

So comparable is here.

If you see this in the comparable.

This is the comparable.

This is an interface right.

They haven't defined it as a function interface and all.

But this also has one abstract method Compared to, which has only accept one method, which only accepts

one method.

That's the only difference.

It has two objects.

Right now it has only one object, and because of this two objects, it gives us a capability that we

can create a new class itself comparator.

Right.

And pass the two objects and do comparison here.

But because here we have only one method, here we have only one method.

Now you cannot create a new class.

You have to have to have use do this kind of stuff only here in the same whatever the object class you

have, you have to do comparable here.

Why?

Because it has only one object like compare two only.

Let's say a car object two.

Object.

One is the one which is invoking this.

This.

So object one would be this which is invoking this car class.

Right.

So this dot you will now do compare something.

So for comparable only option is that you have to the same object class.

You have to use it right.

So now let's see an example I will tell you an example here.

That is the only difference.

So comparable is like comparator helps you that you can do you have so many options right.

You can do lambda expression.

You can create a separate class one class based on the name, one class based on the car type, doing

lot of different ways of sorting.

But in comparator you can have only one type of sorting.

So for example I am creating an integer array.

One two.

Let's say one, seven, 6 or 3.

Now I am doing arrays dot sort array.

Right.

Now what will happen here is this sorting works.

I told you right here internally it will goes and using compares two right.

So here now if here if you see that it is passing an object and then calling compare to.

So it is like let's say it is comparing one and three.

It is comparing one and three.

So this is an integer object right.

So it's like one dot compares to right.

So that's what it is doing right here.

We will see that right.

Uh yeah.

Whatever the value one.

And it's called the compare two.

The value two.

Now here.

So here in the integer it has to implement the comparable now, and since it has implemented the comparable,

it has to have a compare two method integer and it has this method itself.

So now here, if you see that it will always have only one compare logic.

So if this compare logic is written like x minus y kind of thing right.

It is comparing x less than y return minus one.

Right?

So if it is written in this way means it is just doing ascending order, compares two values numerically

it is doing is ascending order.

But if you want to say that, hey, I want to sort in descending order, I.

And if you want to sort in descending order, you need to change the this method write compare method

how you will change it.

Now you can't change it, right?

Because it is here inside this implements here.

and once you have implemented here, you can have only one method.

And in one method the functionality you have provided is for ascending.

Now if you want to do descending order how you will do.

So that's where the comparator comes into the picture.

Comparators is like you don't have to change in this let's say integer class.

You don't have to change in this class.

Right?

I can use a comparator and either can sort in ascending or either can sort in descending also.

But with the comparable it's got fixed.

Right.

Let's take a solve with our custom object class.

It will become more clear to you guys.

So now let's say I want to implement to comparable of this car type.

So I have to implement its method.

I am just doing this dot based on let's say I want to store card type dot compares to object.

So this is my object let's say two object two dot card type okay.

So now I have provided this one compares to method.

And here inside this we have know that it is just two strings Lexicographically.

So now when I'm creating this array car like whether you create a list also let's take a list.

Also it's internal.

It's the same.

Uh.

Car list equals to new array list.

Let's say car dot add.

I'm creating a new car.

First I'm creating SUV with Patrol.

All right.

And second one I am creating a scarlet dot.

Add new car with sedan with CNG.

Now here I am doing Collections.sort car list.

That's all.

Will it work?

Yes, it will work.

How?

Now it lets go.

It goes inside.

Sort list dot sort.

It just compares to array.

Arrays dot sort.

Right.

So comparator is equals to equal to null.

Yes comparator is null I haven't provided the comparator.

It will go inside this.

Let's say it goes into either this or this.

Let's say this most sort here it's calling the Compareto method object one compares to object two.

So here here let's say these are the objects right object one compare to object two.

So object one is your.

car.

Car is your object one right.

So here what it is doing where it goes.

J minus one.

So let's say whatever the index would be let's say SUV sedan.

So index.

So it comes first compares to comparable.

We can do that because our car is a kind of.

A child of this one.

So we can do that.

And now what it is doing here is.

Dot compares two.

So it will call dot compares to method.

And since we have overrided this method it will call this one it will call.

This compares to method and this compares to method.

It will now compare based on this car type right.

That's why it is only accept one object.

The first one would be like the object which invokes it.

This dot car type dot compares to this one.

So now we have only sorting based always sort based on ascending order of card type.

Right.

So this is object one.

Object two.

I am doing object one compares to object two.

Whatever the comparator which we have learned.

Only difference is here we don't have two object.

The first object is present in the same class.

So you have to always implement in the comparable.

Always implement in the object itself.

And you can only do one type of sorting, either ascending or descending.

But with the help of comparator you can either have or you don't need to change.

In this class, you don't need to change in this class.

While calling the sort, you can pass the comparator whether you want to sort in ascending or whether

you want to sort in descending.

I hope this is clear.

This is do practice it.

This is very important.

And it's little bit I can say that I hope I am able to explain very clearly.

There are, uh, so many things here.

Go check it out again.

But you should be very clear.

What's the purpose of comparator and comparator.

How they are different.

So with the help of comparator you don't need to change in the object class.

You don't need to change.

And you can have either ascending and descending while calling the sort method itself.

But in the comparable you have to change in the object class, you have to, and you can only provide

only one type of compare method and one type of sorting.

You have to change in this only that you have to provide a comparable like we have seen.

Okay, let's say string.

A string also might be implementing the.

Comparable and it will since it is implementing the comparable it will have compared to method.

So if you do only with comparable you will have only one type of sorting way.

Okay, guys.

Uh, see you soon.

Bye.
