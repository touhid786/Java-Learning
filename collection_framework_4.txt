
Hey guys, welcome to Concept and Coding.

This is Shreyansh.

And till now in collections we have done queues list iterable collection.

And you might be thinking that next we're gonna start with set right.

But no before even learning this set we have to complete a very important topic which is map, because

in set internally we use map only.

So we have a hash set which internally use hash map.

We have linked hash set which internally use linked hash map.

And we have three set which internally use three map.

So until and unless this map is not cleared we cannot even understand how set is working.

Okay.

So I am first starting with the hash map, uh map and we will go to the set after this one.

Okay.

So now let us start with the map.

And one thing.

Remember that this is the most important topic.

Hash HashMap.

Design HashMap.

Very important and popular interview questions from the Java perspective, right?

So.

But first thing should come to your mind that hey Shreyansh, why the map is not a child of collections.

We know that list is a child of connection.

Stack, link list, queue set.

Everything is child of collection.

Then why not map?

Because till now in collection.

If you see all the methods which are available, it's particularly deal with one value.

They have a list of values.

Value one, value two, value three, value four.

Like this.

And the methods which they provide, they provide all the methods with through which we can work on

this list of, or set of or stack of values.

But in map we have key value All the values we can map to a particular key.

So we have a key value mapping.

So it requires total different methods as the functionality is now changed.

So that's why all the methods which are available in collection is of kind of no use for the map.

Right?

So there is no point of bringing the map under the collection, as collection is just value and map

is deal with key value.

We will see more deeper like how the key value things happen.

Okay.

So now let's start with the map first.

So what are the map property.

So it is an interface.

Yes this is an interface blue one.

And these are all its concrete methods.

Or you can say that the implementations.

Okay.

So its implementations are this.

So object that map keys to values.

So this map help us to create an object either of hash map hash table linked hash map tree map through

which we can store the data in key value form.

So you have one key and then you have value.

So you can have like this 1SJ2 sum p j something like this.

Key value.

Let's say this is row number and this is student name something like this.

So key value pair okay.

Cannot contain duplicate key.

So one of the thing is in this thing value can be duplicate.

So let's say I have say row number three.

It is also nickname is also possible.

So value can be duplicate but keys cannot be duplicate.

If you try to insert one more uh duplicate key, let's say one is already there.

So you will try to say that hey, put one comma some MJ so it will overwrite at whatever the key is

one it will overwrite the value.

Now MJ so at any point of time the duplicate key cannot exist inside a map key value, only one key

can be present.

Okay, so with that being said.

So there are.

Since this is a new interface not a collections.

So there are a lot of new methods you will find.

Right.

There are so many methods.

So I have list down all the popular and most frequently used methods.

Okay.

And see this part I am going to go very much in depth of HashMap okay.

So prepare for it.

So just this methods right.

Have little bit things like okay I will go each method with an example.

But let me first.

Till sixth let me tell you.

And then I will dig more deeper into the HashMap.

And then we'll come back again okay.

There is a reason I will tell you sequentially we will go.

So first is size method which is exposed here.

So what does size matter?

Size method name is.

Okay.

So what it returns.

It returns the number of key value mapping present.

So inside a particular map you have one some SJ2KJ3PJ something four.

So this is known as mapping key value mapping.

So the size will return here for how many key value mapping present is empty.

If your map is totally empty it will return true.

If map even has one key and value, it will return false.

It is not empty contains key.

So if you perform this method contains key and you pass the key.

Let's say I am doing contains key two.

Yes, two is there so it will return true.

If let's say I do five, five doesn't even exist here, so it will return false.

Then here we have a get and put method.

Okay, so if you learn very high level right you would tell that okay get is used to fetch the data.

Put is used to insert the data for example here in this case if I do let's say this is a map is m.

If I do m dot get give me the two what it will return the value which is present for this key.

So what is this present.

Let's say a k k is present.

Let's say so it will return me value k.

This is the output.

So it will return.

This get method will return me the value which is present against this key okay.

Two what is the key two and what the value is k.

So it will return that value.

So put put is used to insert the value in the map.

Okay, so let's say this is a map I am doing.

Put two comma j.

So what it will do is it will first check here two present or not.

If two is not present it will insert.

This is the key.

And this is the value j right.

And if it already exist let's say it want to insert three with j one.

So now it will say that hey three already exists or not, three already exists.

Now whatever the value it was already exists.

It will overwrite.

So S would be overwrite with j one.

Okay, so now I will stop here because this is very high level.

And in interview they will go now more deeper that how Getinput actually works.

And that's where you should be familiar with the design of an HashMap.

This is very very beginner level.

That's generally you would say that yes, when you do play with a method, you will see that yes, it

might be storing like this, but that's not all.

Now let's go into the design part of the map, which is very important.

How the actual data is stored, how actual the data is fetched, how actual the put method and how actual

the get method is performed.

And for that, we have to know first how data or data structures of hash map is okay.

So I am using an example of hash map first okay.

To understand how this works get input.

So let's see this part I am in the hash map class okay so here in the hash map what we have.

Few things we have to know.

First is.

What is load factor?

Another thing we have to know is the entry.

Interface.

And third is.

Rehashing.

And fourth is performance.

So let's first understand these four things in a hashing.

Right.

Uh in a map.

So first let's say that in a map interface right in a map interface.

Apart from this method you will find another called entry.

This is a sub interface.

So this is the.

Entry.

So this is the where is the map?

Yeah.

So this is a map right.

Map interface.

This is your see this is your map interface.

Inside a map interface you will find something called entry interface sub interface.

So this is a sub interface entry.

What.

So now you should say hey why we have a sub interface here.

What is the purpose of it?

I will tell you the purpose of it.

So let's see any implementation.

So this is an interface.

There is no implementation here.

So we have to look at one of the concrete implementation of it.

So I'm taking hash map.

So now here understand this part is that.

How hash map stores the data is you have an array.

This is an array array of entry key comma value.

This is a generic so a key can be of your integer.

String value can be integer, string or anything.

Right.

So it's an array of.

Right.

Array of entry this thing okay.

Then what what does entry kV has.

So now here.

So now let's see HashMap.

What does it has.

So now I am here inside a HashMap.

So now here if you see that what we have is node which is implement map dot entry.

So see I told you entry is a subinterface.

You can't access the Subinterface directly, you have to access it with the parent map dot interface.

We have already seen in the uh interface uh topic.

So we have to implement it right.

Entry Eve.

So in the hash map it is called node kV.

So you can say that it is a node k v array.

Right.

So this entry k v is generally present into a map.

So in HashMap we have created a node kV which implements it because this is an interface in the map.

So we need an implementation part.

Okay.

So what does it has.

So see it has four things.

It has four things.

One is hash key.

Value next.

So next is again node kv.

So it will can point to a similar one.

I will tell you how it is used.

So again it would be as like a hash key value.

Next like this, it will have.

So this is an array.

Okay.

So what should be the size of an array.

First.

So here if you see that where is this node array.

They have defined this here node array.

And they have given a name table.

So first we have to decide the hash table size right.

If you don't define any size if you just create like this let's say I'm creating map I am creating a

map of let's say my key is integer value is a string.

Uh, some x, y, z object name equals to new hash map.

That's all right.

I am creating new hash map and not defining anything.

So what would be the default size of this table would be.

So here it has mentioned all the default things.

Let's see here.

Okay.

So default initial capacity 16.

So it will create an initial capacity of 16.

So let's say 012 till.

15.

So 0 to 15 is your 16.

So this is also hash hash key value.

Next.

Right.

So this is an array of this object okay.

Node kV.

And each node kV object has this four values.

And if you don't provide a size so by default internally it will create a size of 16.

So like this.

Now you will say that hey how it will insert the data here.

So when we say that put one or let us say one comma SJ now how the data is inserted here.

Okay.

Now let's see that how it is inserted.

So whenever you call put method so it do perform couple of steps.

So let us do it here itself so that it would be cleaner.

Okay.

So now let's I am just taking for an example.

I am creating just A33 size instead of 16.

I am just taking three size.

So it would be easy for understanding.

So 012.

So it will have hash key value.

Next hash key value next.

Hash key value next.

Okay.

And I can provide the while creating the map I can even provide the instead I don't have to use a default

initial capacity.

I can provide my.

So let's say I have provided three.

So three is created.

Now let's say I have done a put integer.

So my map hash map is like this integer comma string.

So this is my key.

And this is my value because hash map takes like this.

Generic k comma v.

So first one is k is your key and this is your value.

So key is I have k I have provided as integer and v is provided as a string okay.

So this is key value.

So now I have to do like let's say store one comma.

And string is let's say SJ how it will store the data here.

So first it will do a step called hash.

Okay.

Now in the hashing what it will do is it will pass the key.

So what is the key here one.

So for one it will compute.

It will compute the hash right.

There are so many hashing algorithms you know, that uh, there is like I think MD 1S2 56.

There are so many hashing algorithms present.

So it we can use that also, or we can write even over, uh, something internally.

You can write your own logic also hashing method.

So that for one it gives me some value.

Let's say that uh, it gives me value something.

Let's say 1234567 it compute this hash.

Right.

And then what it will do is it will do Mod size of the table.

What is the size of the table three.

So size of table.

So what would happen is I will get.

The index between this only.

So whatever the hash is got I have to do mod the size of the table so that either it will get ultimately

one of this index only.

Okay.

So now let's say for this one hash was computed as 1234567.

And after I did uh this 1234567 mod three because three is my size of the table hash table.

So let's say it give me an index one.

Let's say it.

Give me an index one.

After this mod I the output is one.

So this is my.

Hash output.

Right.

So now what I have to do is this value or this I have to store where in this one.

In this part I have to store it index one.

Right.

So now let's say what hash was 1234567.

You can put that 1234567 was my hash that generally the key is important.

So key is your one.

Here value is SJ and the next is currently null okay.

Next is currently null.

So now let's say you are trying to insert another element put five comma pj.

So what is the next first step.

It will do hash compute the hash of five.

So what it will do is depending upon the algorithm which we are using for hash, it will compute something.

Let's say 984120 something right.

It compute the hash.

And then we have to do mod of size of the hash table.

It's three.

So what would happen is some index will come right.

Come uh relative to this either zero 1 or 2.

For example, I am saying that let's say that index come is two.

This is the index which you got.

So means this value now has to be stored at this index.

So it will pick this index whatever the hash come is 982410982410.

The key is your five, the value is your PJ and the next is currently null.

Now you can ask me hey what would happen if collision happens.

So there is something what called collision how collision will happen.

So now let's say I am trying to insert ten and trying to put k j.

So now what would be the first step for 1010 we will try to do hash.

So now let's say comes as uh 515100.

Right after that we have to do mod three the size of the table.

So now let's say index come is one.

So at index one we have to store this element.

But here if you see that hey Sean index one there is already an element present how we will store this.

So now what happens inside internally what hash map will do is it will check.

Hey is this the same key as or same hash already present.

So it will check that hey is same key already present?

No.

Earlier it was one.

Earlier I have stored this one.

Now you are trying to insert ten.

So they are not same.

So what it will do is.

So this next write its next of the node itself.

So it will create a new node.

Hash.

It will put this 515100.

Key is your ten.

Value is your key.

Its next is null.

But this will point to this one.

Okay, so that's how it resolves collision.

Whenever there is a collision happen it checks internally that hey the same key which you are trying

to insert.

The same key which you are trying to insert is already present or not.

If it is already present, it would have overrided.

If not, it is stored it right and link it like this.

So similarly it is possible that this list can grow.

This list can grow.

Let's say there are a lot of collisions.

So let's say whenever you are doing put one comma s, put two comma j, put five comma p, whatever

you are doing all whenever you are computing the hash and whenever you are doing mod the index, let's

say which you are getting is one only.

So all would be inserted like this, right?

One, two and five.

All would be stored like this with next, next next next next.

Like a linked list, right?

So let's say one is already stored.

Ten is let's say this is ten.

Ten is already stored.

So two when two will comes.

So it will also have like this.

So key is two value is let's say j.

Next is let's say something.

It's it's hash.

Whatever it's hash is let's say key is five value is p.

Next is let's say null.

So what I am trying to say is that internally the first we have a array of this entry kV and hash map

node implement this.

So first we have an array of this entry kV which defines the initial capacity of a hash map.

And once we have defined the initial capacity, what we will do is we will during we will do put we

will insert an element like this.

And whenever there is a collision happen we make a chaining.

Or you can say that we add it as a linked list.

Okay.

So now remember two things here.

One is load factor.

Another is you can say that uh, you can say that this threshold or t fi threshold, I let me tell you

two things.

First let's talk about load factor.

Till now it's clear, right.

How actually the map internally stores the data.

Right.

So you might have linked list kind of here also data okay.

So now let's say first before even I go to the load factor.

Let's see what happens if, let's say I do get ki, I want to say that I get five.

How it will do so first internally will perform hash okay.

So now it will perform hash.

So hash will return the same data for the five.

Let's say for five.

It was what it was written.

So we haven't discussed that one for five.

So let's say when we inserted that for five for five when we inserted P here.

Right.

So it the key it came was let's say 616100 something.

So when you do get of five the hash function should generate the same key.

Right.

So I will get again 616100.

The hash function should return the same hash function hash key I will do mod the size of the table.

Let's say it is three.

I will get this index.

Let's say one index is one.

So means at this index this five might be present.

Now it will internally iterate.

Internally iterate over this linked list to find out a map.

It will it will see.

Hey is key is equals to equals to five.

No it is one.

Hey key equals to equals to five.

No it is ten.

So it will go to the next.

Then it will go hey key is equals to equals to five.

No it is two.

It will go to its next.

Hey key equals to equals to five.

Yes it will be return this value p.

So output would be p.

Right.

So you understand how get and put works.

Now you have heard one thing like whenever the get is trying to find the hash of a particular key,

it should get the same key.

Why?

There is a contract.

Understand this.

Learn this one contract between

hashCode and equal method.

Okay, so there are two methods hashCode and equal.

hashCode method is the one which help us to generate the hash.

Equals is a method where we are doing comparison during get.

We are comparing right?

Hey, let's say we want to point a five.

Hey five keys one.

This is five.

Is it equal or not?

This object is equal or not.

This object is equal or not.

Yes, this object is equal.

So equal is method to compare the two objects.

But what is the contract.

So there are two contract.

First contract says that if object one is equals to equals to object two.

If object one and object two are same, then.

Their hash.

Should be also same.

If two objects are same, their hash should also be same.

Another contract between them is if two object hash is same doesn't means that two objects are equal.

So these are the two contract.

Let's understand that.

What is the first contract says that if object one is equals to object two, both are equal, then their

hash should be same also no matter what.

So no matter, let's say if you are doing for five, you are getting a hash one, 234.

This is the hash function.

So it takes five and generate this hash function.

No matter how many times you run this hash function for the five, you always get the same hash.

Only that's what it says, that if object one is equals to object two, then their hash should be also

same.

So this property, this contract makes guarantee that no matter how many times you call hash, if you

call hash with the same value, you will always get the same hash output.

So that's why during put during put five comma, let's say any value whatever the hash functions come

for five.

Let's say 616100.

Now during get.

Also when I'm doing for five it will again try to find out a hash.

It will generate the same hash and this will help us to go to a particular index.

This is the first property.

You know that.

Why this first property helpful in get input method.

They will help us to generate the same same kind of hash and through which we can get a particular index.

Second property says that if two object hash is same doesn't means that doesn't means that two objects

are equal.

That is correct right.

So we have seen that.

So here if you see that this two.

Right.

So this two might be you can say that hash comes equal right.

So let's say that hash of six and hash of eight it can comes equal.

It comes like 51510.

It can come also 51510.

It is possible, right?

Maybe internally it hash function internally might be doing like this.

Uh, like uh six into seven.

Some calculations.

Right.

Plus ten minus something.

So trying to generate a hash.

So it is possible that for other number also the same hash function or same hash value can come.

Okay.

So it has to be understand that if the hash value are same doesn't mean that the objects are same.

That's why we have like we have keep hash key value.

So even this hash of two objects are same 515100 doesn't mean they are same.

So never ever compare this hash.

Don't rely on this hash.

It can be same.

It cannot be same for two objects, so always compare value.

Also.

So generally if you see the logic it matches hash and key both.

So if both are same then it will show during get.

For five you will get a hash.

So what it will do is it will compare the hash also and the value also.

If both matches then it will return right.

So these are the two contracts between hash code and equal right.

Now you can ask that Haitians.

This when we are so where we are doing a link list internally we are storing the data like this in hash

map.

Right.

So here we also have a node and we are storing like this.

So how hash map is guaranteed.

Or you can say that average performance of HashMap is big O of one for insertion.

For deletion.

For finding how it able to offer big O of one time complexity.

How?

First thing.

So just understand this now very importantly.

So there is a concept called.

So you know right.

There is one disadvantage here is that let's say if there is you did put of ten elements.

So key is one some value key is two some value key is three.

Some value key is ten some value.

What if the hash function generates the same index for all.

And internally we are using linked list.

So we would be storing here one, two, three.

Its value and the next.

Four, five, six, seven.

So now you can say that.

Hey, if I have to find, let's say ten and ten is here inside a linked list, then for the ten the

hash will come.

It will give me an index zero.

Then I have to iterate.

Right.

Then how come it's big O of one?

I have to iterate.

Hey, is it ten?

No.

Is it ten?

No.

Is it ten?

No.

Go to the next.

Go to the next.

Go to the next.

Go to the next.

So it is big O of N.

Worst time complexity.

Yes.

So the average time complexity is big O of one.

And the worst time complexity of hash map is big O of n.

So now you can say that hey on how come average It makes a time complexity big of one.

It's a very high chance that it will create a long list high.

It's a very high probability that if I am inserting this linked list will become huge.

If there are so many collision.

So how it maintains this average.

So this load balancer load factor help us to do that.

So what does load factor is.

So here if you don't define anything what's the load factor of hash map currently is 0.75.

Default load factor is 0.75.

Now what is that.

So now let's say initial.

What is the initial size or initial table for the hash map is let's say 16 right.

012.

Three.

And let's say this is 15 0 to 15.

16.

This is the initial hash map.

All empty.

Load factor is 0.75.

So what does it say?

Is that 16 into load factor 0.75 which is generally comes at 12 whenever the 12 data or whenever the

12 key value mapping is insert into this table, it will do rehash.

It will do rehash okay means it will increase the size.

It will increase the size or double the size.

Okay.

So earlier it was 16.

Then it will become 32, then it will become 64, then 128.

So in all these multiple of two and so initial size was so this is initial size.

Initial size was oh 16.

Load factor I have determined 0.75.

So as soon as you have 12 data.

So let's say this is your hash key value.

Next.

So you have let's say one value is something and then you have another data.

Here some data here you have some data.

Then you have some data here.

Right.

Just understand this is any data okay.

So you will have some data here.

There are collision.

You will make a list like a linked list here.

As soon as it reaches this 12 threshold 16 the size of the initial hash map into the load factor.

So 12 as soon as you will insert the 13th element key value, what it will do is it will do rehash.

So what it will do is it will increase the size of a hash map and then compute the index for them.

Again, it will rehash them into the new, because now it would be the new index, right.

So it will rehash them.

So maybe this data now come here.

Maybe this data earlier it was index three.

Now it will come some here.

Right.

So that's load factor one.

Help.

It does it it don't let your linked list to grow much as soon as it says that.

Hey there are uh 12 there is a threshold increase.

Let okay.

The size is see if the size is small only.

Let's say this 3012.

And if you insert 100 items inside this 012, definitely there would be collision, right?

Definitely there would be collision.

Right.

So because 100 items you have to put into this three index.

Definitely there will be collision if you make this linked list and your linked list would be grow.

And if linked list grows you have to iterate.

So your searching and insertion time complexity increases.

So load factor.

What it does is as soon as it says that hey, as soon as the capacity threshold increases or crossed,

it will increase this size of a hash map itself.

So when the size of a hash table increases, what will happen is definitely there would be less collision

as they have more space, right?

So definitely the searching and uh, all the operation deletion and all would be faster also.

Okay.

So you understand what is load factor, but is it a guaranteed that load factor help you to increase

the size?

No.

Then there is one more thing.

What if you have a sufficient space?

What if you have a sufficient space?

Zero.

One.

Two.

Let's say 127.

Right.

Because of load factor, you have a, let's say sufficient space.

But again, whatever the put you are doing, it's all turning out to be a collision.

Let's say worst scenario possible.

Right.

It's possible it can all turn out to be a particular linked list only.

So how to avoid that now.

So here if you see that there is something called untry phi uh, tree Phi threshold.

Three Phi threshold.

What is this tree?

Phi threshold.

So initial is eight.

So what it does is internally.

Whenever the collision happens, you create a linked list.

Okay.

So now currently in the linked list how many items are there.

So this is

123456.

Let's say seven.

Let's say you are doing another port.

Same because of hash.

Uh let's say hash comes at 9200.

You did mod 128 the size of a hash map.

So you got index zero.

Let's say again you put whatever the put you want it to do.

You add it here.

So 12345678.

So now if you see that as soon as you are doing another put you are trying to insert another value.

And let's say index again comes zero and you want to insert it over here now.

But what is the three?

Five threshold is eight.

As soon as you reach till that eight and you wanted to insert more than that, what it will do is it

will convert the linked list into.

Three you can say that it's a balanced binary search tree.

You know that binary search tree, right?

Uh, whatever the value, the left side is smaller than the parent node, and the right node is greater

than the parent node.

Like this.

Right.

So it used a balanced binary search tree might be red black red black tree internally.

So it will convert this linked list into binary search tree balanced one May be red black tree because

it's a balance.

You will always kind of a balanced one, right?

AVL is also balanced binary tree.

But I think internally it uses red black tree.

Right.

Uh, so that because binary search tree also possible it can go like this itself.

So it uh red black tree avoid it and make it balanced like this.

So that searching would be in log of n.

So if there are too much collision happening and everything coming out to be a same index of r f an

array, then worst time complexity is big O of n in case of linked list, uh, but it has provided three

five threshold eight.

So after as soon as limit to the eight it will convert it to a binary search array.

And you know that in binary search you when you find it, whether you go here or here.

Right?

So after this you will go here or here.

So it will always be log of n, not o of n.

You can learn binary search tree or maybe in the data structures part.

I am not covering binary search tree, but binary search tree.

Search complexity is log of n.

You always do one part of the tree, either left or right.

You don't do access full.

So that's why.

So here if you see that, put 12.

So whenever we are inserting an element into the HashMap is check the bin count.

So bin count is nothing but this only this is called either bucket or bin.

If it reaches the threshold, if it reaches the threshold, it will three five.

It will construct this linked list into tree.

You can instantly goes and check how it construct the tree.

Now what is the worst case?

Time complexity?

You can say that here.

Average.

Average time complexity is big O of one for insertion.

Searching.

Deletion.

Everything.

Worst case, if we are using internally linked list, it would be big O of N, but generally we don't

use linked list.

After a particular size of linked list, we convert it to a tree.

So it's big O of log n.

So just wanted to tell before you even say this answer big of log n.

Always tell that first you try to make a linked list, but for linked list there is a threshold.

If it reached till that threshold, it will convert that tree to convert that linked list to tree.

So generally we never have big O of often, right?

As we convert that linked list to tree.

So big of log log n is the worst time case complexity for hash map.

Got it.

So you got this concept right.

When we are doing put what actually happens and when we are doing get what actually happens how actually

it stores the data.

Okay.

Now let's go to the more method.

Like let's say we have remove remove.

What will happen is it will remove the element from the key.

I will show you with an example of this one.

It will be a more uh like this one.

Just take this example.

So now in this example I am creating one map hash map HashMap.

Okay, so now here inside that what I am doing is I am putting null comma test, right.

I am putting null comma test.

So first of all few things I haven't defined anything.

So maybe default size of an array they have taken might be 16 0 to 15 right.

And it's an array of what.

It's an array of node kV array okay.

So what is the kV here.

So k here is my integer.

So my this is my k integer.

And this is my value is a string.

So what it put is null test okay.

So this is the key.

So for null it first find out a hash of null and it will do mod size of the table.

Let's say 16.

It will find out some index.

Let's say it will put it here.

Let's say two comes so it will put null test then zero comma null key.

Let's say again then I am doing hash of zero.

Whatever comes I will do mod 16.

Let's say it comes here zero and value is null.

So now here just notice that in the hash map I can have even the key as null and the value as a null.

Also.

Then one a let's say one is stored over here.

Here itself one A this is key.

This is value.

There is a hash also.

I'm not storing it just for simplification two let's say two is stored here.

Two value is b currently next is null.

Okay, so now this is how you know already how it works.

Then there is a method called put if absent.

Okay.

So what this method does, it will say that if the value is null, if the value is null for a given

key.

So the key is this null okay.

If the value if the key doesn't even exist, or the value of a key is null, then it will add this data.

So now my key is null.

So put.

If absent so does null exist?

Yes.

Null exist.

Okay.

This key is present.

What it is value test.

So test value exists.

It is not.

It's value is not null.

So it will not write this data.

It will not write this data All right.

So now I am doing another put if absent zero comma.

This is the put if absent.

So zero.

So does zero exist.

Yes.

This is the key.

Zero.

What its value null.

Its value is null.

Right.

So it will overwrite this with this value put if absent.

So when it considered as absent either this key is not there or if key is exist, even its value is

null.

It will then write this data.

So it will replace this null with zero.

So it will write this data with.

Overwrite its data with zero.

Three with c.

So now say three exists no does not exist.

So let us say it will insert its a hash of three comes something mod six uh 16.

Lets say its come here.

So it will put three.

See here.

Okay.

Then you will do a print out here.

So now how you will iterate the hash map.

See this method.

So there is something called entry set.

What this entry set method returns entry set method returns you this I told you right.

It's an array of this one entry k k comma v right.

It's a.

You can say that it's a kind of an array you are getting.

A map dot entry integer string kV.

You got this.

And now you are iterating one by one.

So for each an array internally you are having just a node only, right?

These are all nothing but an entry kV node kV right.

So you will get this array.

And now you are iterating one by one.

So for each node what all value it has node has your key value hash rate.

So it has an appropriate method get key.

It will return the key get value.

It will return the value right.

And you can print that you understand right.

What does entry set returns.

Entry set returns this.

All this which is what is this node.

This node is node of k comma v class.

Right.

This is the object node.

We have an array of this and it has hash key value.

And next right so all these three has.

So it returns the array of this.

And from each of this we can take out its key value.

So when you run this what it printed first whatever we have stored till now.

So we have stored till now here null which is test zero is replaced with zero here.

If you see that earlier zero was null, but put if present, we did right.

So for the null value it replaced it with the zero.

So zero is now replaced with zero.

And then we have put 1A2B3C1A2B3C.

Then we check is empty method hashmap dot is empty.

No, we have the data so it will return false.

What is the size.

So it will just print the size 12345.

Does it contains.

This is the key.

Does it contains three?

Yes.

Key is three exists true.

The get method get one.

You know already.

Now how get works.

First it will compute the hash.

Then from the hash it will do mod table size.

It will go to a particular index.

From that it will iterate over a linked list or a tree and do equals compare.

Write it.

Value is same or not.

After that it finds it right.

But get one.

Does one exist?

Yes.

One exists.

What?

It will return.

It will return value of it.

A value is a.

Okay, then after that.

Getdefault.

So this is also like if the value does not present, it will give it like nine nine does not present

key zero one, two three or null is present, nine is not there, so it will return this default value.

Get or default return.

Default value.

Remove particular key null.

So I am removing this now null.

Remove this key.

So I am just iterating over that.

Now here if you see that it removes the key value.

So I am removing it at this point of time when I removed it, right?

Remove it, removed this element and returns the whatever the element is removed.

So now when I iterated it, see that key null is missing.

Key set.

So there is one more method present into the hash map is like hash map dot key set.

Now what this key set will do.

It will return you this this key.

It takes out all the keys and give you in a set and return it right.

So you can just like a list collection, you can iterate over the key itself.

I am iterating over the keys zero, one, two, three.

Similarly, there is a method called values dot values.

So you can just iterate over the values and just print it.

Right.

So my values was a string right.

So collection of values which is of a string.

And I am iterating it.

So values are 0ABC right.

So here value 0ABC.

So here if you see that these are all the methods which are present.

But very important you have to know is how hash map works.

Right.

So now you also know the time complexity of hash map.

Also this is just an average amortized amortized means average.

Worst case you already know if we are using linked list internally it will give big O of N but linked

list we generally have a particular size.

After that we move to the tree file or tree a balanced binary search tree which gives big O of log n.

So worst case time complexity is big O of log n.

Hash map is clear right in the hash table is very very similar to hash map.

So remember that hash map is not thread safe.

It is not thread safe.

Hash table is thread safe.

That's all.

That's the only difference.

And then one more thing is here.

Uh, here.

Hash map.

Do not maintain the order.

Yes, they do not maintain.

Hash table is a synchronized version of hash map.

It's a synchronized version of hash map.

So generally if you see that in the hash map I can I told you that a hash map can have null key and

null value.

Hash table do not contains null key or null value.

No.

Second thing is hash map is not thread safe, hash table is thread safe.

And also you can use concurrent hash map that is also a thread safe.

So hash map has two variants.

You can say that.

So this is not thread safe.

And its two variants which are thread safe is concurrent hash map and hash table.

Hash table is exactly same as hash map.

Apart from that, there is no difference.

It is thread safe.

Second, you cannot store either null key or null value.

That's all.

Everything else is same.

Okay, so these two I have covered today.

I will cover in the link hash map and tree map in the next video.

But but do practice hash map and understand this hash map internals very well.

Right.

If you have any doubt with this, what load factor is how the data is stored in the map actually, right.

Just don't always see that okay?

This is key value.

Here we store key.

Here we store value.

No I told you right.

How actually internally is stored.

It's an array of this.

Right.

So practice this one.

Any doubt let me know.

Right.

Okay.

So see you soon guys.

Thank you.

Bye.

